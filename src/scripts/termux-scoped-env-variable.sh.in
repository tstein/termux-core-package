#!@TERMUX__PREFIX@/bin/sh
# shellcheck shell=sh
# shellcheck disable=SC3043

##
# `termux_core__sh__termux_scoped_env_variable__show_help`
##
termux_core__sh__termux_scoped_env_variable__show_help() {

    cat <<'HELP_EOF'
termux-scoped-env-variable.sh can be used to get/set/unset variable
names and values for `TERMUX*__` and other scoped environment
variables exported by different Termux runtime components, with
support for fallback values and validation of values.


Usage:
  termux-scoped-env-variable.sh <command> <args...>


Available commands:
    get-name                     Get Termux scoped variable name.
    get-value                    Get Termux scoped variable value.
    set-value                    Set Termux scoped variable value.
    unset-value                  Unset Termux scoped variable value.



get-name:
  termux-scoped-env-variable.sh get-name \
    <output_mode> \
    <scoped_var_scope_mode> <scoped_var_sub_name>



get-value:
  termux-scoped-env-variable.sh get-value \
    <output_mode> \
    <scoped_var_scope_mode> <scoped_var_sub_name> \
    <posix_validator> [<default_values...>]



set-value:
  termux-scoped-env-variable.sh set-value \
    <scoped_var_scope_mode> <scoped_var_sub_name> \
    <value_to_set>



unset-value:
  termux-scoped-env-variable.sh unset-value \
    <scoped_var_scope_mode> <scoped_var_sub_name>



Available arguments:
- `output_mode`: The output mode for the command.
  If set to a valid environment variable name (like `TERMUX__VAR`),
  then output will be set to the variable.
  Otherwise, it must be set to `>` so that output is printed to
  `stdout`, or set to `-` so that output is not printed at all and
  only exit code is returned.
- `scoped_var_scope_mode`: The scope mode of the scoped environment
  variable name to get/set/unset.
- `scoped_var_sub_name`: The sub name of the scoped environment
  variable name to get/set/unset after the scope name.
- `posix_validator`: The posix validator for whether a
  particular variable value is valid and should be returned or not.
- `default_values`: One or more fallback default values. This may
  optionally be a placeholder value that gets replaced during build
  time.
- `value_to_set`: The value to set to the scoped environment variable.



The `get-name` command type returns the name of the Termux scoped
environment variable generated depending on the variable scope and sub
name passed.

The `get-value` command type returns the value for the Termux scoped
environment variable generated depending on the variable scope and sub
name passed. First its value is read from the environment, followed by
reading the optional values passed as `default_values`, and whichever
value first matches the `posix_validator` is returned and if no
value matches, then the call will return with exit code
`81` (`C_EX__NOT_FOUND`). If the `scoped_var_scope_mode` argument is
not set, then the environment variable is not read and only any
default values passed are checked.

The `set-value` command type sets the value of the Termux scoped
environment variable generated to the value passed as `value_to_set`.

The `unset-value` command type unsets the value of the Termux scoped
environment variable generated by running the `unset` command.

The `set-value` and `unset-value` command types are not available if
executing the `termux-scoped-env-variable.sh` script as they will
not have any effect on the calling process environment and are only
available if the script is sourced and the
`termux_core__sh__termux_scoped_env_variable` function is called.



The scoped environment variable name to get/set/unset is generated
based on the `scoped_var_scope_mode` and `scoped_var_sub_name`
arguments.
The `scoped_var_scope_mode` argument must be equal to one of
the following formats:
- `s=<scoped_var_scope_name>`: The variable name is generated as per
  `${scoped_var_scope_name}${scoped_var_sub_name}`. The root scope
  is assumed to be part of the `scoped_var_scope_name` argument and
  Termux root scope is not prefixed to it. This can be used if
  `scoped_var_scope_name` was already generated with the Termux root
  scope or if getting a variable for an external app under a
  different root scope.
- `ss=<scoped_var_sub_scope_name>`: The variable name is generated as per
  `${root_scope_name}${scoped_var_sub_scope_name}${scoped_var_sub_name}`,
  where the `root_scope_name` is the value set in the
  `$TERMUX_ENV__S_ROOT` environment variable, with a fallback to the
  build time placeholder`@TERMUX_ENV__S_ROOT@`, and then to the
  hardcoded root scope value `TERMUX_` for the upstream Termux app.
- `cn=<scoped_var_component_name>`: The variable name is generated as
    per the component name passed from the list below, where the value
    in the bracket defines the sub scope value used for variable name
    generation.
    - `cn=termux`            (`ss="_"`)
    - `cn=termux-app`        (`ss="APP__"`)
    - `cn=termux-api-app`    (`ss="API_APP__"`)
    - `cn=termux-float-app`  (`ss="FLOAT_APP__"`)
    - `cn=termux-gui-app`    (`ss="GUI_APP__"`)
    - `cn=termux-tasker-app` (`ss="TASKER_APP__"`)
    - `cn=termux-widget-app` (`ss="WIDGET_APP__"`)
    - `cn=termux-x11-app`    (`ss="X11_APP__"`)
    - `cn=termux-core`       (`ss="CORE__"`)
    - `cn=termux-exec`       (`ss="EXEC__"`)

Optionally, only the `scoped_var_scope_mode` argument may be
passed with the `scoped_var_sub_name` argument as an empty string.
This can be used for the `get-name` command and a
`ss=<scoped_var_sub_scope_name>` formatted argument to get the
full scope name with the Termux root scope prefixed to the sub scope.



The `posix_validator` argument must be equal to one of the
following formats. The `value` refers to the values that are checked
for a match, like defined by the Termux scoped environment variable
or the `default_values`.
- `?`: Matches `value` if it is set and not empty.
- `*`: Matches `value` if it is set, or defined but empty.
- `p+=<pattern>`: Matches `value` if it matches the `<pattern>`.
- `p-=<pattern>`: Matches `value` if it does not match the `<pattern>`.
- `c+=<command>`: Matches `value` if `<command>` passed the `value` as
                  an argument exits with exit code `0`.
- `c-=<command>`: Matches `value` if `<command>` passed the `value` as
                  an argument does not exit with exit code `0`.

For the `p+=pattern` and `p-=pattern` formats, the leading `p+=` or
`p-=` characters are removed from `posix_validator`
and remaining part is used as is as the pattern for a shell `case`
construct that is dynamically generated using the `eval` command to
match against the `value`. Since `eval` command is used, **DO NOT**
pass untrusted code as `posix_validator` and only a valid
`case` construct pattern must be passed. For example, the argument
`p+='/*'` would match a `value` that is a valid absolute path
(including rootfs `/`). For more info, check:
- https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_09_04_05
- https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_13


For the `c+=<command>` and `c-=<command>` formats, the leading `c+=`
or `c-=` characters are removed from `posix_validator` and
remaining part is passed as an argument to `<command>` and executed.
The `<command>` string must be set to an executable in `$PATH`,
or a path to an executable, or a function name in the current
execution environment, optionally followed with arguments.
This is checked with the `command -v` command and if that fails, then
the first argument is checked to see if its an absolute or relative
path to an executable (`+x`) file. For more info, check:
- https://pubs.opengroup.org/onlinepubs/9699919799/utilities/command.html

The `value` is passed as the last argument to `<command>`, or the
first if `<command>` itself does not have any argument.
Arguments in `<command>` should be separated with a space ` `
character but themselves must not contain any whitespace (IFS)
characters as that will result in them splitting into
multiple arguments, since `<command>` string is executed without
quotes like `$command`. Any quotes surrounding the arguments will be
treated literally.
The `stdout` and `stderr` streams are not redirected to
`/dev/null` when executing the command, and must be manually done
in the function if required or the quiet `-q` options be used for
commands like `grep`, otherwise the `stdout` of the command will
pollute the normal result output for the matched value if it is to be
printed to `stdout`.
For example, the arguments `c+='value_validator'` and
`c+='value_validator some_arg'` would match the `value` if the
commands `value_validator "value"` and
`value_validator some_arg "value"` respectively would exit with exit
code `0`.
Note that if `termux-scoped-env-variable.sh` is being
executed, instead of the
`termux_core__sh__termux_scoped_env_variable` local function
being called, any function in the `<command>` argument will not be
defined in the executed child process, as POSIX shells do not
support exporting functions, like `bash` does with the
`export -f <function>` command. If a function needs to be passed,
the `termux_core__sh__termux_scoped_env_variable` function should
be sourced and executed in the same shell environment/process as
the validator function.
For more info, check:
- https://www.gnu.org/software/bash/manual/bash.html#Shell-Functions
- https://www.gnu.org/software/bash/manual/bash.html#index-export



**See also:**
- @TERMUX_CORE_PKG__REPO_URL@/blob/master/site/pages/en/projects/docs/usage/utils/termux-scoped-env-variable.md
- @TERMUX_CORE_PKG__REPO_URL@/blob/master/src/scripts/termux-scoped-env-variable.sh.in
- @TERMUX_PACKAGES__REPO_URL@/blob/master/packages/termux-core/src/scripts/termux_core__sh__termux_scoped_env_variable
HELP_EOF

}

##
# `termux_core__sh__termux_scoped_env_variable__main` [`<argument...>`]
##
termux_core__sh__termux_scoped_env_variable__main() {

    local return_value

    if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
        termux_core__sh__termux_scoped_env_variable__show_help || return $?
        return 0
    elif [ "$1" = "--version" ]; then
        echo "@TERMUX_CORE_PKG__VERSION@" || return $?
        return 0
    elif [ "$1" = "set-value" ] || [ "$1" = "unset-value" ]; then
        echo "The '$1' command cannot be run if executing the 'termux-scoped-env-variable.sh' script." 1>&2
        return 80 # C_EX__UNSUPPORTED
    else
        termux_core__sh__termux_scoped_env_variable "$@"
        return_value=$?
        if [ $return_value -eq 64 ]; then # EX__USAGE
            echo ""
            termux_core__sh__termux_scoped_env_variable__show_help
        fi
        return $return_value
    fi

}

##### @TERMUX_CORE__SH__TERMUX_SCOPED_ENV_VARIABLE@ to be replaced at build time. #####

##
# Check if script is sourced.
# - https://stackoverflow.com/a/28776166/14686958
# - https://stackoverflow.com/a/29835459/14686958
#
# To source the `termux-scoped-env-variable.sh` file in `$PATH`
# (with `.` command), run the following commands.
# The `command -v` command is used to find the location of the script
# file instead of directly using the `.`/`source` command to prevent
# sourcing of a (malicious) file in the current working directory with
# the same name instead of the one in `$PATH`.
# A separate function is used to source so that arguments passed to
# calling script/function are not passed to the sourced script.
# Passing the `--sourcing-script` argument is necessary if sourcing
# from a `sh` shell script so that script `main` function is not run
# as there is no POSIX way to detect if current script is being
# sourced from another script as `${0##*/}` expansion in the
# "all other shells" case will contain name of the script that is
# sourcing the current script instead of the shell name.
# The `--not-sourcing-script` flag can be passed in case of executing
# the script for efficiency as that will skip the logic of checking if
# script is being sourced or not.
# Replace `exit` with `return` if running inside a function.
# ```shell
# source_file_from_path() { local source_file="${1:-}"; [ $# -gt 0 ] && shift 1; local source_path; if source_path="$(command -v "$source_file")" && [ -n "$source_path" ]; then . "$source_path" || return $?; else echo "Failed to find the '$source_file' file to source." 1>&2; return 1; fi; }
# source_file_from_path "termux-scoped-env-variable.sh" --sourcing-script || exit $?
# ```
##
if [ "${1:-}" = "--sourcing-script" ]; then
    TERMUX_CORE__SH__TSEV__SOURCING_SCRIPT="true"; shift 1;
elif [ "${1:-}" = "--not-sourcing-script" ]; then
    TERMUX_CORE__SH__TSEV__SOURCING_SCRIPT="false"; shift 1;
else
    TERMUX_CORE__SH__TSEV__SOURCING_SCRIPT="false"
    if [ -n "${ZSH_EVAL_CONTEXT:-}" ]; then
        case "$ZSH_EVAL_CONTEXT" in *:file) TERMUX_CORE__SH__TSEV__SOURCING_SCRIPT="true";; esac
    elif [ -n "${KSH_VERSION:-}" ]; then
        # shellcheck disable=SC2296
        case "$KSH_VERSION" in # mksh, like on Android, will throw `${.sh.file}: bad substitution`.
            *"MIRBSD KSH"*) case "${0##*/}" in sh|ksh) TERMUX_CORE__SH__TSEV__SOURCING_SCRIPT="true";; esac;;
            *) [ "$(cd "$(dirname -- "$0")" && pwd -P)/$(basename -- "$0")" != "$(cd "$(dirname -- "${.sh.file}")" && pwd -P)/$(basename -- "${.sh.file}")" ] && TERMUX_CORE__SH__TSEV__SOURCING_SCRIPT="true";;
        esac
    elif [ -n "${BASH_VERSION:-}" ]; then
        (return 0 2>/dev/null) && TERMUX_CORE__SH__TSEV__SOURCING_SCRIPT="true"
    else
        # For all other shells, examine `$0` for known shell binary filenames.
        # Detects `sh` and `dash`, add additional shell filenames as needed.
        case "${0##*/}" in sh|-sh|dash|-dash) TERMUX_CORE__SH__TSEV__SOURCING_SCRIPT="true";; esac
    fi
fi

# If script is sourced, return with success, otherwise call main function.
if [ "$TERMUX_CORE__SH__TSEV__SOURCING_SCRIPT" = "true" ]; then
    return 0 # EX__SUCCESS
else
    termux_core__sh__termux_scoped_env_variable__main "$@"
    exit $?
fi
