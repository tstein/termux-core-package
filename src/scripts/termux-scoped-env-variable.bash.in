#!@TERMUX__PREFIX@/bin/bash
# shellcheck shell=bash

if [ -z "${BASH_VERSION:-}" ]; then
    echo "The 'termux-scoped-env-variable.bash' script must be run from a 'bash' shell."; return 64 2>/dev/null|| exit 64 # EX__USAGE
fi

##
# `termux_core__bash__termux_scoped_env_variable__show_help`
##
termux_core__bash__termux_scoped_env_variable__show_help() {

    cat <<'HELP_EOF'
termux-scoped-env-variable.bash can be used to get/set/unset variable
names and values for `TERMUX*__` and other scoped environment
variables exported by different Termux runtime components, with
support for fallback values and validation of values.


Usage:
  termux-scoped-env-variable.bash <command> <args...>


Available commands:
    get-name                     Get Termux scoped variable name.
    get-value                    Get Termux scoped variable value.
    set-value                    Set Termux scoped variable value.
    unset-value                  Unset Termux scoped variable value.



get-name:
  termux-scoped-env-variable.bash get-name \
    <output_mode> \
    <scoped_var_scope_mode> <scoped_var_sub_name>



get-value:
  termux-scoped-env-variable.bash get-value \
    <output_mode> \
    <scoped_var_scope_mode> <scoped_var_sub_name> \
    <extended_validator> [<default_values...>]



set-value:
  termux-scoped-env-variable.bash set-value \
    <scoped_var_scope_mode> <scoped_var_sub_name> \
    <value_to_set>



unset-value:
  termux-scoped-env-variable.bash unset-value \
    <scoped_var_scope_mode> <scoped_var_sub_name>



Available arguments:
- `output_mode`: The output mode for the command.
  If set to a valid environment variable name (like `TERMUX__VAR`) or
  a bash array variable (like `TERMUX__ARRAY[0]`), then output will be
  set to the variable.
  Otherwise, it must be set to `>` so that output is printed to
  `stdout`, or set to `-` so that output is not printed at all and
  only exit code is returned.
- `scoped_var_scope_mode`: The scope mode of the scoped environment
  variable name to get/set/unset.
- `scoped_var_sub_name`: The sub name of the scoped environment
  variable name to get/set/unset after the scope name.
- `extended_validator`: The extended validator for whether a
  particular variable value is valid and should be returned or not.
- `default_values`: One or more fallback default values. This may
  optionally be a placeholder value that gets replaced during build
  time.
- `value_to_set`: The value to set to the scoped environment variable.



The `get-name` command type returns the name of the Termux scoped
environment variable generated depending on the variable scope and sub
name passed.

The `get-value` command type returns the value for the Termux scoped
environment variable generated depending on the variable scope and sub
name passed. First its value is read from the environment, followed by
reading the optional values passed as `default_values`, and whichever
value first matches the `extended_validator` is returned and if no
value matches, then the call will return with exit code
`81` (`C_EX__NOT_FOUND`). If the `scoped_var_scope_mode` argument is
not set, then the environment variable is not read and only any
default values passed are checked.

The `set-value` command type sets the value of the Termux scoped
environment variable generated to the value passed as `value_to_set`.

The `unset-value` command type unsets the value of the Termux scoped
environment variable generated by running the `unset` command.

The `set-value` and `unset-value` command types are not available if
executing the `termux-scoped-env-variable.bash` script as they will
not have any effect on the calling process environment and are only
available if the script is sourced and the
`termux_core__bash__termux_scoped_env_variable` function is called.



The scoped environment variable name to get/set/unset is generated
based on the `scoped_var_scope_mode` and `scoped_var_sub_name`
arguments.
The `scoped_var_scope_mode` argument must be equal to one of
the following formats:
- `s=<scoped_var_scope_name>`: The variable name is generated as per
  `${scoped_var_scope_name}${scoped_var_sub_name}`. The root scope
  is assumed to be part of the `scoped_var_scope_name` argument and
  Termux root scope is not prefixed to it. This can be used if
  `scoped_var_scope_name` was already generated with the Termux root
  scope or if getting a variable for an external app under a
  different root scope.
- `ss=<scoped_var_sub_scope_name>`: The variable name is generated as per
  `${root_scope_name}${scoped_var_sub_scope_name}${scoped_var_sub_name}`,
  where the `root_scope_name` is the value set in the
  `$TERMUX_ENV__S_ROOT` environment variable, with a fallback to the
  build time placeholder`@TERMUX_ENV__S_ROOT@`, and then to the
  hardcoded root scope value `TERMUX_` for the upstream Termux app.
- `cn=<scoped_var_component_name>`: The variable name is generated as
    per the component name passed from the list below, where the value
    in the bracket defines the sub scope value used for variable name
    generation.
    - `cn=termux`            (`ss="_"`)
    - `cn=termux-app`        (`ss="APP__"`)
    - `cn=termux-api-app`    (`ss="API_APP__"`)
    - `cn=termux-float-app`  (`ss="FLOAT_APP__"`)
    - `cn=termux-gui-app`    (`ss="GUI_APP__"`)
    - `cn=termux-tasker-app` (`ss="TASKER_APP__"`)
    - `cn=termux-widget-app` (`ss="WIDGET_APP__"`)
    - `cn=termux-x11-app`    (`ss="X11_APP__"`)
    - `cn=termux-core`       (`ss="CORE__"`)
    - `cn=termux-exec`       (`ss="EXEC__"`)

Optionally, only the `scoped_var_scope_mode` argument may be
passed with the `scoped_var_sub_name` argument as an empty string.
This can be used for the `get-name` command and a
`ss=<scoped_var_sub_scope_name>` formatted argument to get the
full scope name with the Termux root scope prefixed to the sub scope.



The `extended_validator` argument must be equal to one of the
following formats. The `value` refers to the values that are checked
for a match, like defined by the Termux scoped environment variable
or the `default_values`.
- `?`: Matches `value` if it is set and not empty.
- `*`: Matches `value` if it is set, or defined but empty.
- `r+=<regex>`: Matches `value` if it matches the `<regex>`.
- `r-=<regex>`: Matches `value` if it does not match the `<regex>`.
- `c+=<command>`: Matches `value` if `<command>` passed the `value` as
                  an argument exits with exit code `0`.
- `c-=<command>`: Matches `value` if `<command>` passed the `value` as
                  an argument does not exit with exit code `0`.

For the `r+=<regex>` and `r-=<regex>` formats, the leading `r+=` or
`r-=` characters are removed from `extended_validator` and
remaining part is matched against the `value` with the bash `=~` if
conditional. The `<regex>` argument must be a valid POSIX extended
regular expression (`REG_EXTENDED`).
For example, the argument `r+='^((/)|((/[^/]+)+))$'` would match a
`value` that is a valid absolute path (including rootfs `/`).
For more info, check:
- https://www.gnu.org/software/bash/manual/html_node/Conditional-Constructs.html#index-_005b_005b
- https://www.man7.org/linux/man-pages/man3/regex.3.html
- https://www.man7.org/linux/man-pages/man7/regex.7.html

For the `c+=<command>` and `c-=<command>` formats, the leading `c+=`
or `c-=` characters are removed from `extended_validator` and
remaining part is passed as an argument to `<command>` and executed.
The `<command>` string must be set to an executable in `$PATH`,
or a path to an executable, or a function name in the current
execution environment, optionally followed with arguments.
This is checked with the `command -v` command and if that fails, then
the first argument is checked to see if its an absolute or relative
path to an executable (`+x`) file. For more info, check:
- https://pubs.opengroup.org/onlinepubs/9699919799/utilities/command.html

The `value` is passed as the last argument to `<command>`, or the
first if `<command>` itself does not have any argument.
Any arguments in `<command>` itself should be quoted with single or
double quotes if they have whitespace (IFS) characters, like
`c+='value_validator "some arg"`.
The `stdout` and `stderr` streams are not redirected to
`/dev/null` when executing the command, and must be manually done
in the function if required or the quiet `-q` options be used for
commands like `grep`, otherwise the `stdout` of the command will
pollute the normal result output for the matched value if it is to be
printed to `stdout`.
For example, the arguments `c+='value_validator'` and
`c+='value_validator some_arg'` would match the `value` if the
commands `value_validator "value"` and
`value_validator some_arg "value"` respectively would exit with exit
code `0`.
Note that if `termux-scoped-env-variable.bash` is being
executed, instead of the
`termux_core__bash__termux_scoped_env_variable` local function
being called, any function in the `<command>` argument must first be
exported with the `export -f <function>` command to be defined in
the executed child process, assuming if executing from a `bash` shell.
For more info, check:
- https://www.gnu.org/software/bash/manual/bash.html#Shell-Functions
- https://www.gnu.org/software/bash/manual/bash.html#index-export



**See also:**
- @TERMUX_CORE_PKG__REPO_URL@/blob/master/site/pages/en/projects/docs/usage/utils/termux-scoped-env-variable.md
- @TERMUX_CORE_PKG__REPO_URL@/blob/master/src/scripts/termux-scoped-env-variable.bash.in
- @TERMUX_PACKAGES__REPO_URL@/blob/master/packages/termux-core/src/scripts/termux_core__bash__termux_scoped_env_variable
HELP_EOF

}

##
# `termux_core__bash__termux_scoped_env_variable__main` [`<argument...>`]
##
termux_core__bash__termux_scoped_env_variable__main() {

    local return_value

    if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
        termux_core__bash__termux_scoped_env_variable__show_help || return $?
        return 0
    elif [ "$1" = "--version" ]; then
        echo "@TERMUX_CORE_PKG__VERSION@" || return $?
        return 0
    elif [ "$1" = "set-value" ] || [ "$1" = "unset-value" ]; then
        echo "The '$1' command cannot be run if executing the 'termux-scoped-env-variable.bash' script." 1>&2
        return 80 # C_EX__UNSUPPORTED
    else
        termux_core__bash__termux_scoped_env_variable "$@"
        return_value=$?
        if [ $return_value -eq 64 ]; then # EX__USAGE
            echo ""
            termux_core__bash__termux_scoped_env_variable__show_help
        fi
        return $return_value
    fi

}

##### @TERMUX_CORE__BASH__TERMUX_SCOPED_ENV_VARIABLE@ to be replaced at build time. #####



##
# Check if script is sourced.
# - https://stackoverflow.com/a/28776166/14686958
# - https://stackoverflow.com/a/29835459/14686958
#
# To source the `termux-scoped-env-variable.bash` file in `$PATH`
# (with `.` or `source` command), run the following commands.
# The `command -v` command is used to find the location of the script
# file instead of directly using the `.`/`source` command to prevent
# sourcing of a (malicious) file in the current working directory with
# the same name instead of the one in `$PATH`.
# A separate function is used to source so that arguments passed to
# calling script/function are not passed to the sourced script.
# Replace `exit` with `return` if running inside a function.
# ```shell
# source_file_from_path() { local source_file="${1:-}"; [ $# -gt 0 ] && shift 1; local source_path; if source_path="$(command -v "$source_file")" && [ -n "$source_path" ]; then source "$source_path" || return $?; else echo "Failed to find the '$source_file' file to source." 1>&2; return 1; fi; }
# source_file_from_path "termux-scoped-env-variable.bash" || exit $?
# ```
##

# If script is sourced, return with success, otherwise call main function.
if (return 0 2>/dev/null); then
    return 0 # EX__SUCCESS
else
    termux_core__bash__termux_scoped_env_variable__main "$@"
    exit $?
fi
